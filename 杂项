## 项目介绍
首先值得说的是我们这个项目，项目也是使用常规的cra脚手架，然后安装了craco依赖对webpack进行扩展，与大众化不同值得提的地方是

第一个我们公司属于医疗行业，项目大多会部署到医院内网，也就是说部署环境比较特殊，特殊的地方有两点，第一个是有些医院内网属于局域网无法访问外网，针对这种情况我们根据打包命令会把类似iconfont的所有依赖直接打包进去；第二个是有些医院项目部署到内网使用外网访问，但是限速只有100k，所以我们需要针对这种情况尽量减少打包体积，针对这点除了常规的操作，我们增加了webpack external配置，吧例如antd这类依赖全部使用cdn加载，使项目体积得到大幅度缩减；

第二个就是我们项目特殊的架构吧，不知道是见得少还是真没人用，之前问了下大家都没见过这种清奇的架构思路，就我们公司主要只有一个前端项目，但是业务项目有十几个，包括PC移动端各种场景。当时也是刚来公司领导让做一个可以敏捷开发的项目，实现0配置快速搭建。

整个项目第一个特殊的就是，因为我们领导之前在网易做游戏，所以我们这边的思路是所有页面配置基本都适用excel配置，然后py脚本导表在配合jinkens直接把生成的json文件写入前后端项目。前端使用的时候直接读取json文件生成页面就行，后端键值也一样。这一步配置由前后端辅助产品完成，脚本都是前端写得，然后产品配置excel，把前端的一部分工作量分配给了产品，减少了工作量。也便于后期产品修改项目配置，不需要改个什么东西都要来麻烦前端，自己修改一下excel就可以；

第二个特殊的就是关于我们怎么做到1对多，除了常规的项目结构外，我们在src目录下面有一个project目录，里面每一个子目录都是一个单独的项目配置，里面包含了一个入口文件，然后项目单独的路由，项目配置，已经产品导入的配置。在运行项目的时候我们会根据node参数加载不同的项目配置实现加载不同的业务项目。例如一般项目都是yarn start，我们一般会第三个参数，项目名，甚至于不同的环境会加上其他参数，当然了大部分参数都是通过配置文件写入的。

这里之所以使用单独路由，是因为项目太大，有些业务项目用不上组件的，会增加项目体积等等

## react


### fiber
react对于核心算法的一种重构

在16以前整个更新过程是同步的，diff整个虚拟dom树从上往下再网上，整个过程无法中断，如果层级较深，可能会造成页面阻塞。

16以后引入了fiber，他是一个承载各种节点信息的工作单元，也是一个对象，与16以前不同的是他解决了痛点，每个fiber执行完成都会去查看是否有优先级更高的任务，如果有就会中断当前任务，为了实现这一工作，react团队实现了一个类似requestidlecallback的功能，之所以不用原生的这个api是因为受限于它的25帧限制。

这个api的作用就是在浏览器空闲的时候会去执行优先级相对低的任务

### unsafe生命周期
+ componentwillmount 第一次渲染可能被中断，因此unmount周期不一定会被执行，会造成内存渲染
+ componentwillreceiveprops 在这个周期里面修改父组件值，可能会造成重复执行死循环
+ componentwillupdate 因为这个与didmount中间会有一段时间，如果在这个时间拉升浏览器会造成页面数据不对
getSnapshotBeforeUpdate  getDerivedStateFromProps

### 合成事件
一是为了磨平差异性，使得开发者不需要关注兼容性，二是为了统一管理事件，提高性能

事件委托，所有的事件都绑定在最外层，使用一个统一的事件监听，简化事件处理回收机制，提升效率

## 前端模块化

### COMMONJS
所有代码都运行在模块作用域，不会污染全局，首次加载完成就会缓存，后续再次加载只会返回缓存结果，需要清除缓存才会再次执行。输出的是值的拷贝

主要用在node服务端，以同步的方式加载模块，因为服务端模块文件都存在磁盘，读取速度非常快。不适用于浏览器端，因为受限于网络原因，更适合异步加载

### es6 module
+ commonjs是运行时加载，esm是编译时输出接口
+ commonjs是加载整个模块，esm则是加载其中单独的接口
+ commonjs输出的是值的拷贝，esm输出的是值的引用，模块内部改变会影响外部引用的改版
+ comonjs值的拷贝，es6为值的引用

### AMD&&requirejs
异步加载机制，对于依赖的模块，推崇依赖前置，提前知悉，也就是说在define方法里传入的依赖模块会在一开始就下载执行

### CMD
依赖就近，延迟加载，只有在require的时候才会执行

## 页面渲染流程
1. dns解析域名获得ip
2. 浏览器访问服务器
3. 三次握手后，服务器处理完成返回资源
4. 浏览器拿到资源后解析生成页面
    1. 生成dom树
    2. 生成cssom树
    3. 执行js
    4. 生成render tree
    5. 生成页面布局
    6. 渲染节点样式
重绘repaint 回流reflow

## 项目优化
+ 减少http请求
+ 域名拆分，增加浏览器并行速度
+ 图片合并
+ gzip压缩
+ cdn加载依赖
+ 按需加载
+ 懒加载

## 线程进程
故名意思每个进行中的程序就是进程，每个进程里面有多个线程，每个线程负责单独的任务，进程的内存是独立的，进程里面的线程共享内存

浏览器网络请求是多线程的，页面渲染是单线程的

## 网络
### 网络安全
#### xss 跨站脚本攻击
+ 反射型xss  攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。
+ dom型xss 主要表现为修改页面dom节点，属于前端漏洞
+ 储存性xss 持久性 把恶意脚本存放在服务器
编码转义
#### csrf 跨站伪造请求
是一种劫持受信任用户向服务器发送非预期请求的攻击方式。

检查refer token验证

httponly 如果设置了则js脚本无法渠道cookie信息

## fetch axios
fetch收到一个错误码的时候不会进入reject而是会进入resolve

axios也是封装的xhmhttprequest的，如果没有则走的node http模块
```
 // 用 XHR 发起一个GET请求\
var xhr = new XHMHttpRequest();
xhr.open('GET', url);
 xhr.responseType = 'json';  
xhr.onload = function(){}; 
 xhr.onerror = function(){};
 xhr.send();
 
// 用 Fetch 完成同样的请求\
fetch(url).then(function(response){
return response.json();
}).then(function(jsonData){}).catch(function(){  });
```

## 三次握手
1. 客户端发送同步序列编号给服务端，自己进入等待状态
2. 服务端接受到后，吧同步序列编号与确认字符打包一起发送给客户端
3. 客户端收到后，再把确认字符发送给服务端
4. 服务端把数据发送给客户端

## 防抖 节流
+ 事件触发N秒后如果没有重新触发则执行，否则重新计时

+ 事件连续触发时，N秒才执行一次

```
    const debounce = (fn, delay) => {
        let timer = null
        return () => {
          if (timer) {
            clearTimeout(timer)
            timer = null
          } else {
            timer = setTimeout(() => {
              fn()
              timer = null
            }, delay);
          }
        }
      }
      const throttling = (fn, delay) => {
        let timer = null
        return () => {
          if (!timer) {
            fn()
            timer = setInterval(() => {
              clearInterval(timer)
              timer = null
            }, [delay])
          }
        }
      }
      const th = debounce(msg, 300)
      const de = throttling(msg, 2000)
      document.querySelector('#btn').addEventListener('click', () => {
        // th()
        de()
      })
```

## 手写promise

## webpack
https://juejin.cn/post/6844904094281236487
### loader plugin

loader本质是插件，对内容进行转换，对资源进行预处理以便于webpack能读懂；

plugin是插件，扩展webpack功能，一般是通过监听webpack事件，在需要的时候改变输出结果

### webpack构建流程
1. 初始化参数，从配置文件与shell语句中读取合并参数
2. 从第一步得到的参数加载各种插件
3. 确定入口， 通过入口文件，找到所有依赖文件调用配置的loader对其进行编译
4. 编译完成后得到各个模块直接的依赖关系，组装成一个个包含多个模块的chunk代码块
5. 把输出的文件内容写入文件系统

### source map
是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。

### 热加载原理


# 待完成
页面渲染流程 -三次握手，dns解析过程
react渲染流程
webpack技术点
提高效率的工具
