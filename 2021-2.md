## 目录
React的Diff原理 Fiber结局什么问题 时间分片的大概原理 hooks原理以及为什么会出现hooks setState原理 React优化方案

webpack的构建流程 plugins和loader的区别 webpack构建优化方式有哪些 webpack的分包策略 

promise async/await原理 手写订阅发布模式 bind原理 new原理 网络相关问题

状态码 http协议中的缓存控制 keep-alive和多路复用的区别 http2.0的特性 头部压缩原理 tcp握手 udp和tcp区别 dns原理 https原理 浏览器相关问题

eventLoop 关键渲染路径 加载原理 DOM树和渲染树区别 回流和重绘 性能优化相关问题

白屏优化方案 长列表优化方案 Node相关问题

egg了解吗 洋葱模型 node的eventLoop和浏览器的区别 如何保证node的高可用，容灾等措施 node如何发布

# REACT
## React的Diff原理
+ dom节点跨层级操作较少，只有创建删除操作
+ 组件间的diff，如果是相关组件可以通过 shouldComponentUpdate 控制，不同组件则直接删除创建
+ 元素节点的比较，相比于之前的删除 创建比较方法，新增了通过key来优化识别，做到移动操作

## fiber架构
一个对象，存储了节点信息。

在16以前的版本都是直接遍历树diff，无法终止，层级较深的时候会阻塞主线程，造成页面卡顿；

fiber引入了调度器，把进程进行了切片，每个fiber执行完成都会看一下是否有优先级更高的任务，如果有会放弃当前的操作去执行高优先级的任务，利用空闲时间回来执行；

## hooks原理 为什么需要
因为在167以前组件里面的逻辑状态复用很难，需要借助高阶组件，但是高阶组件需要重构代码，而且会带来很多嵌套，另外class写法有学习成本，并且逻辑容易混乱都写在一个生命周期

所以有了hook，最大的好处就是解决了状态复用，可以把逻辑封装成自己用hook

### 原理 
1. 初始化阶段，每次使用 hook 都会调用 mountWorkInProgressHook 函数，生成一个 hook 对象
2. hook 对象的基本结构

```
{
  memoizedState:null, //储存usestate 值
  baseState:null, // 每次更新产生的值
  baseQueue:null, // 当前的队列
  queue: null , // 更新队列
  next: null, // 指向下一个hook
}
```

3. 在组件初始化完成后会形成一个链表，最终绑定在 workInProgress 的 memoizedState 上面，hook 的状态也绑定在这个属性上面；

但是 effect 副作用钩子，会绑定在 workInProgress 的 updateQueue 上面，在 commit 阶段执行完成后依次触发。使用深度遍历获取

4. 在更新的时候会执行 updateWorkInProgressHook 函数

#### usestate

初始化的时候调用 mountstate 函数，把 initstate 赋值给 memoizedState 和 baseState，queue 保存负责更新的事件

更新时，获取新的 hook，合并 queue，更新值，返回新的 memoizedState

#### useeffect

初始化的时候调用 mountEffect 函数，在创建完 hook 把 信息 存入 memoizedState，并且其中还会调用 pushEffect 函数把 effect 放入 workInProgress 的 updateQueue 中

更新的时候判断 deps 是否变化， 如果没有变化则直接执行 pushEffect，如果不相等则更新 effect，并赋值给 memoizedState

#### usememo

初始化的时候执行第一个参数的函数，生成要缓存的值，然后将值与 deps 记录下来，赋值给 memoizedState

更新的时候判断 deps 是否变化，没有更新直接返回缓存的值，如果有更新则重新生成并赋值给 memoizedState

```
function mountMemo(nextCreate,deps){
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
```

#### useRef

初始化的时候创建一个 ref 对象，用对象的 current 属性保存 initvalue，最后写入 memoizedState

更新的时候没有任何变化，直接返回之前的 hook.memoizedState

```
function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = {current: initialValue};
  hook.memoizedState = ref;
  return ref;
}
```


## setstate同步还是异步
同步的，只不过react有队列机制，所以看起来是异步的。在react事件中会把isbatchupdate设为true标识有队列，结束后会设置成false

而在原生事件及settimeout里面，不会走react的机制，所以是同步的


## setState原理

## React优化方案

## 扩展问题
### 为什么不能在循环里面使用hook
看hook原理

# node npm
## npm安装原理
+ 执行npm install后，会根据package.json递归获取依赖关系树
+ 检查本地是否有缓存，如果没有则从registry 远程获取下载地址
+ 下载包缓存在.npm文件夹，win系统缓存在app-data npm-cache
+ 解压下载的包，写入node-modules

针对重复的包，如果是相互兼容的则保存高版本的，如果不兼容则会保留两个包

# js基础
## object.prototype.tostring.call instanceof Array.isArray typeof
1 可能被修改原型链导致错误

2 是判断原型链上面是否有原型，弊端是只能判断对象 可能被修改原型链导致错误

3 是最好的方法，不过可能存在不兼容

4 只能判断基础类型

## call apply bind
共同之处：改变this指向 

不同之处：bind不会立即执行，call apply会立即执行；call接受参数，apply接受数组

## let const var
var 存在变量提升 可以重复声明
let const 不会变量提升，不能重复声明，存在锁死。const 与 let不同的是const定义的引用不能修改

## 内存管理
现在一般使用的是引用标记，变量进入上下文的时候会将其标记为引用，出去的时候则标为不再引用，但不是不要就释放，而是在下一次垃圾回收时回收；

在老版本的ie中使用的是标记计数，最早期会实时的垃圾回收，非常影响性能

### 内存泄露
首先明白内存泄露的定义，是指不需要的变量依然占用内存不会被释放，堆积起来最终导致卡死等等

1. 常见的是在非严格模式里面，内部变量会自动提升为全局变量，导致不会被释放
2. 其次就是定时器这种，当定时器引用外部变量的时候，定时器没有结束会导致变量一直存在
3. 然后是dom的引用，比如现在定义了a变量执行一个节点，a如果在使用后没有设空，那么后期即使删除了这个节点，依然会存在

# 残题收集
1. 如何判断是网址
new URL() 方法，错误的话使用trycatch捕获
```
function isURL (ulr) {
  try{
    new URL(ulr)
    return true
  }catch(err){return false}
}
```

## iife
```
var b = 10;
(function b() {
   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
    b = 20;
    console.log(b); // [Function b]
    console.log(window.b); // 10，不是20
})()
```

# 算法思维
## 中心扩散法
