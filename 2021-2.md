## 目录
React的Diff原理 Fiber结局什么问题 时间分片的大概原理 hooks原理以及为什么会出现hooks setState原理 React优化方案

webpack的构建流程 plugins和loader的区别 webpack构建优化方式有哪些 webpack的分包策略 

promise async/await原理 手写订阅发布模式 bind原理 new原理 网络相关问题

状态码 http协议中的缓存控制 keep-alive和多路复用的区别 http2.0的特性 头部压缩原理 tcp握手 udp和tcp区别 dns原理 https原理 浏览器相关问题

eventLoop 关键渲染路径 加载原理 DOM树和渲染树区别 回流和重绘 性能优化相关问题

白屏优化方案 长列表优化方案 Node相关问题

egg了解吗 洋葱模型 node的eventLoop和浏览器的区别 如何保证node的高可用，容灾等措施 node如何发布

# REACT
## React的Diff原理
+ dom节点跨层级操作较少，只有创建删除操作
+ 组件间的diff，如果是相关组件可以通过 shouldComponentUpdate 控制，不同组件则直接删除创建
+ 元素节点的比较，相比于之前的删除 创建比较方法，新增了通过key来优化识别，做到移动操作

## fiber架构
一个对象，存储了节点信息。

在16以前的版本都是直接遍历树diff，无法终止，层级较深的时候会阻塞主线程，造成页面卡顿；

fiber引入了调度器，把进程进行了切片，每个fiber执行完成都会看一下是否有优先级更高的任务，如果有会放弃当前的操作去执行高优先级的任务，利用空闲时间回来执行；

## hooks原理 为什么需要
因为在167以前组件里面的逻辑状态复用很难，需要借助高阶组件，但是高阶组件需要重构代码，而且会带来很多嵌套，另外class写法有学习成本，并且逻辑容易混乱都写在一个生命周期

所以有了hook，最大的好处就是解决了状态复用，可以把逻辑封装成自己用hook

### 原理 
hook的结构
```
export type Hook = {
  memoizedState: any, // 最新的状态值
  baseState: any, // 初始状态值，如`useState(0)`，则初始值为0
  baseUpdate: Update<any, any> | null,
  queue: UpdateQueue<any, any> | null, // 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针
  next: Hook | null,  // 指向下一个链表节点
};
```
只是数组+cursor，在初始化时会创建两个数组setter state，调用usestate的时候会吧set函数放入setter，初始值放入state；

每次更新都会重置cursor为0，如果放在循环里面会导致cursor错误

## setstate同步还是异步
同步的，只不过react有队列机制，所以看起来是异步的。在react事件中会把isbatchupdate设为true标识有队列，结束后会设置成false

而在原生事件及settimeout里面，不会走react的机制，所以是同步的


## setState原理

## React优化方案

## 扩展问题
### 为什么不能在循环里面使用hook
看hook原理

# node npm
## npm安装原理
+ 执行npm install后，会根据package.json递归获取依赖关系树
+ 检查本地是否有缓存，如果没有则从registry 远程获取下载地址
+ 下载包缓存在.npm文件夹，win系统缓存在app-data npm-cache
+ 解压下载的包，写入node-modules

针对重复的包，如果是相互兼容的则保存高版本的，如果不兼容则会保留两个包

# js基础
## object.prototype.tostring.call instanceof Array.isArray typeof
1 可能被修改原型链导致错误

2 是判断原型链上面是否有原型，弊端是只能判断对象 可能被修改原型链导致错误

3 是最好的方法，不过可能存在不兼容

4 只能判断基础类型

## call apply bind
共同之处：改变this指向 

不同之处：bind不会立即执行，call apply会立即执行；call接受参数，apply接受数组

## let const var
var 存在变量提升 可以重复声明
let const 不会变量提升，不能重复声明，存在锁死。const 与 let不同的是const定义的引用不能修改

## 内存管理
现在一般使用的是引用标记，变量进入上下文的时候会将其标记为引用，出去的时候则标为不再引用，但不是不要就释放，而是在下一次垃圾回收时回收；

在老版本的ie中使用的是标记计数，最早期会实时的垃圾回收，非常影响性能

### 内存泄露
首先明白内存泄露的定义，是指不需要的变量依然占用内存不会被释放，堆积起来最终导致卡死等等

1. 常见的是在非严格模式里面，内部变量会自动提升为全局变量，导致不会被释放
2. 其次就是定时器这种，当定时器引用外部变量的时候，定时器没有结束会导致变量一直存在
3. 然后是dom的引用，比如现在定义了a变量执行一个节点，a如果在使用后没有设空，那么后期即使删除了这个节点，依然会存在

# 残题收集
1. 如何判断是网址
new URL() 方法，错误的话使用trycatch捕获
```
function isURL (ulr) {
  try{
    new URL(ulr)
    return true
  }catch(err){return false}
}
```

## iife
```
var b = 10;
(function b() {
   // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
  // （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）
    b = 20;
    console.log(b); // [Function b]
    console.log(window.b); // 10，不是20
})();
```
